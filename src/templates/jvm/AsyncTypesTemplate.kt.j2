// Async return type handlers

{# add imports that we use #}
import kotlin.coroutines.Continuation
import kotlin.coroutines.resume
import kotlin.coroutines.resumeWithException

{# We use these in the generated functions, which don't have access to add_import() -- might as well add it here #}
import kotlin.coroutines.suspendCoroutine
import kotlinx.coroutines.coroutineScope

// FFI type for callback handlers

{%- for callback_param in ci.iter_future_callback_params() %}
actual class UniFfiFutureCallback{{ callback_param.canonical_name() }}(private val inner: (ULong, {{ callback_param|ffi_type_name }}, RustCallStatusByValue) -> Unit) : com.sun.jna.Callback {
    // Note: callbackData is always 0.  We could pass Rust a pointer/usize to represent the
    // continuation, but with JNA it's easier to just store it in the callback handler.
    // FIXME use template function for _callbackData
    fun invoke(_callbackData: ULong, returnValue: {{ callback_param|ffi_type_name }}, callStatus: RustCallStatusByValue) {
        inner(_callbackData, returnValue, callStatus)
}   }
{%- endfor %}

// Callback handlers for an async call.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
{%- for result_type in ci.iter_async_result_types() %}
{%- let callback_param = result_type.future_callback_param() %}
actual fun create{{ result_type|future_callback_handler }}Data(continuation: {{ result_type|future_continuation_type }})
                      : {{ result_type|future_callback_handler }}Data =
    {{ result_type|future_callback_handler }}Data(
        UniFfiFutureCallback{{ callback_param.canonical_name() }} { _: ULong, returnValue: {{ callback_param|ffi_type_name }}, callStatus: RustCallStatusByValue ->
           try {
                    checkCallStatus({{ result_type|error_handler }}, callStatus)
                    {%- match result_type.return_type %}
                    {%- when Some(return_type) %}
                    continuation.resume({{ return_type|lift_fn }}(returnValue))
                    {%- when None %}
                    continuation.resume(Unit)
                    {%- endmatch %}
                } catch (e: Throwable) {
                    continuation.resumeWithException(e)
                }
        },
        DropHandle(),
        // on the JVM, the continuation is held by UniFfiFutureCallbackHandleru64 so we do not need handle native
        // pointers. The JVM does not let us pass a dummy Pointer.NULL, so we insert some garbage that
        // must not be touched instead
        Pointer.createConstant(0xCAFED00DL)
    )

{%- endfor %}

actual class DropHandle<T> {
    actual fun dropIt() {
        // no-op on the JVM
    }
}
