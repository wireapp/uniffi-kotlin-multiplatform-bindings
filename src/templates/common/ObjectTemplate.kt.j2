{% import "helpers.j2" as helpers %}
import kotlinx.coroutines.coroutineScope
import okio.Buffer
import kotlin.coroutines.cancellation.CancellationException
import kotlin.coroutines.resumeWithException
import kotlin.coroutines.suspendCoroutine

interface {{ type_name }}Interface {
    {% for meth in obj.methods() -%}
    {%- match meth.throws_type() -%}
    {%- when Some with (throwable) %}
    @Throws({{ throwable|type_name }}::class{%- if meth.is_async() -%}, CancellationException::class{%- endif -%})
    {%- else -%}
    {%- endmatch %}
    {% if meth.is_async() -%}
    suspend fun {{ meth.name()|fn_name }}({% call helpers::arg_list_decl(meth) %})
    {%- else -%}
    fun {{ meth.name()|fn_name }}({% call helpers::arg_list_decl(meth) %})
    {%- endif %}
    {%- match meth.return_type() -%}
    {%- when Some with (return_type) %}: {{ return_type|type_name -}}
    {%- else -%}
    {%- endmatch %}
    {% endfor %}
}

class {{ type_name }}(
    pointer: Pointer
) : FFIObject(pointer), {{ type_name }}Interface {

    {%- match obj.primary_constructor() %}
    {%- when Some with (cons) %}
    constructor({% call helpers::arg_list_decl(cons) -%}) :
        this({% call helpers::to_ffi_call(cons) %})
    {%- when None %}
    {%- endmatch %}

    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            UniFFILib.{{ obj.ffi_object_free().name() }}(this.pointer, status)
        }
    }

    {% for meth in obj.methods() -%}
    {%- match meth.throws_type() -%}
    {%- when Some with (throwable) %}
    @Throws({{ throwable|type_name }}::class{%- if meth.is_async() -%}, CancellationException::class{%- endif -%})
    {%- else -%}
    {%- endmatch %}
    {%- if meth.is_async() %}
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun {{ meth.name()|fn_name }}({%- call helpers::arg_list_decl(meth) -%}){% match meth.return_type() %}{% when Some with (return_type) %} : {{ return_type|type_name }}{% when None %}{%- endmatch %} {
        // Create a new `CoroutineScope` for this operation, suspend the coroutine, and call the
        // scaffolding function, passing it one of the callback handlers from `AsyncTypes.kt`.
        //
        // Make sure to retain a reference to the callback handler to ensure that it's not GCed before
        // it's invoked
        var callbackDataHolder: {{ func.result_type().borrow()|future_callback_handler }}Data? = null
        try {
            return coroutineScope {
                val scope = this
                return@coroutineScope suspendCoroutine { continuation ->
                    try {
                        val callbackData = create{{ meth.result_type().borrow()|future_callback_handler }}Data(continuation)
                        callbackDataHolder = callbackData
                        callWithPointer { thisPtr ->
                            rustCall { status ->
                                UniFFILib.{{ meth.ffi_func().name() }}(
                                    thisPtr,
                                    // FIXME create macro that handles the comma
                                    {% call helpers::_arg_list_ffi_call(meth) %}{% if func.arguments().len() > 0 %},{% endif %}
                                    FfiConverterForeignExecutor.lower(scope),
                                    callbackData.resultHandler,
                                    callbackData.continuationRef,
                                    status,
                                )
                            }
                        }
                    } catch (e: Exception) {
                        continuation.resumeWithException(e)
                    }
                }
            }
        } finally {
           callbackDataHolder?.dropHandle?.dropIt()
        }
    }
    {%- else -%}
    {%- match meth.return_type() -%}

    {%- when Some with (return_type) -%}
    override fun {{ meth.name()|fn_name }}({% call helpers::arg_list_protocol(meth) %}): {{ return_type|type_name }} =
        callWithPointer {
            {%- call helpers::to_ffi_call_with_prefix("it", meth) %}
        }.let {
            {{ return_type|lift_fn }}(it)
        }

    {%- when None -%}
    override fun {{ meth.name()|fn_name }}({% call helpers::arg_list_protocol(meth) %}) =
        callWithPointer {
            {%- call helpers::to_ffi_call_with_prefix("it", meth) %}
        }
    {% endmatch %}
    {% endif %}
    {% endfor %}

    {% if !obj.alternate_constructors().is_empty() -%}
    companion object {
        {% for cons in obj.alternate_constructors() -%}
        fun {{ cons.name()|fn_name }}({% call helpers::arg_list_decl(cons) %}): {{ type_name }} =
            {{ type_name }}({% call helpers::to_ffi_call(cons) %})
        {% endfor %}
    }
    {% endif %}
}

object {{ obj|ffi_converter_name }}: FfiConverter<{{ type_name }}, Pointer> {
    override fun lower(value: {{ type_name }}): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): {{ type_name }} {
        return {{ type_name }}(value)
    }

    override fun read(source: NoCopySource): {{ type_name }} {
        return lift(source.readLong().toPointer())
    }

    override fun allocationSize(value: {{ type_name }}) = 8

    override fun write(value: {{ type_name }}, buf: Buffer) {
        buf.writeLong(lower(value).toLong())
    }
}
